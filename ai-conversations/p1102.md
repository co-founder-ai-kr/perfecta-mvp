# 민순의 요청

```text
* 역할: 너는 구글 앱스 스크립트 전문 개발자야.
* 상황: '스크립트 속성'에 저장된 API 키를 사용하여 챗 봇의 두뇌를 연결하고 싶어.
* 과업:
  1. `GOOGLE_API_KEY` 속성을 불러오는 코드를 작성해 줘.
  2. 사용자의 질문(`userQuery`)과 구글 시트에서 가져온 데이터(`context`)를 합쳐서 제미나이 API에 전송하고, 답변을 받아오는 `callGeminiAPI` 함수를 작성해 줘.
  3. 웹 앱으로 배포할 거니까 `doPost` 함수를 사용해서 작성해 줘.
* 제약:
  - 복사해서 바로 쓸 수 있게 전체 코드를 제공해 줘.
  - 코드의 각 부분이 어떤 역할을 하는지 '주방장'과 '재료'에 비유해서 한글 주석을 달아 줘.
* 출력: 앱스 스크립트 코드 블록
* 입력: [구글 시트 데이터 구조]
 (예시: 시트 이름은 'Data', A열은 질문, B열은 답변 내용이 들어 있어.)
```

# 제미나이의 응답

네, 구글 앱스 스크립트(GAS) 전문 개발자입니다.

요청하신 대로 **스크립트 속성(Script Properties)**을 활용하여 보안을 유지하고, **구글 시트의 데이터**를 지식(Context)으로 삼아 **제미나이(Gemini) API**와 소통하는 전체 코드를 작성해 드립니다.

코드의 각 부분에는 이해를 돕기 위해 **'주방장(로직)'**과 **'재료(데이터)'**에 비유한 주석을 달았습니다.

### 📋 사전 준비 사항
코드를 붙여넣기 전에 다음 단계가 완료되어 있어야 합니다.
1.  **API 키 저장**: 앱스 스크립트 에디터 왼쪽 메뉴의 **[프로젝트 설정]** (톱니바퀴 아이콘) > **[스크립트 속성]**에서 `GOOGLE_API_KEY`라는 이름으로 제미나이 API 키를 값에 저장하세요.
2.  **시트 준비**: 같은 스프레드시트 파일 내에 **'Data'**라는 이름의 시트가 있어야 하며, A열에는 질문, B열에는 답변 데이터가 있어야 합니다.

---

### 💻 구글 앱스 스크립트 코드

```javascript
/**
 * ------------------------------------------------------------------
 * [주방장 노트: 전체 설정]
 * 이 코드는 손님(사용자)의 주문(질문)을 받아, 
 * 창고(구글 시트)에 있는 재료(데이터)를 꺼내,
 * 수석 셰프(제미나이 AI)에게 요리(답변)를 부탁하는 과정입니다.
 * ------------------------------------------------------------------
 */

// 제미나이 API 모델 설정 (수석 셰프의 이름)
const GEMINI_MODEL = 'gemini-pro';
const API_VERSION = 'v1beta';

/**
 * 1. [주문 접수 창구]: 웹 앱으로 들어오는 요청(POST)을 처리하는 함수
 * @param {Object} e - 손님의 주문서 (HTTP 요청 데이터)
 */
function doPost(e) {
  // [재료 준비]: 금고(스크립트 속성)에서 비밀 레시피 키(API Key)를 꺼냅니다.
  const scriptProperties = PropertiesService.getScriptProperties();
  const apiKey = scriptProperties.getProperty('GOOGLE_API_KEY');

  // [검수]: API 키가 없으면 주문을 거절합니다.
  if (!apiKey) {
    return createJSONOutput({ error: 'API 키가 설정되지 않았습니다.' });
  }

  try {
    // [주문 확인]: 손님이 보낸 주문서(JSON)를 읽습니다.
    const requestBody = JSON.parse(e.postData.contents);
    const userQuery = requestBody.userQuery; // 손님의 질문

    // [재료 손질]: 구글 시트 창고에서 참고할 데이터(Context)를 가져옵니다.
    const context = getSheetContext();

    // [요리 시작]: 수석 셰프(제미나이)에게 재료와 주문을 전달하고 요리를 받아옵니다.
    const aiResponse = callGeminiAPI(userQuery, context, apiKey);

    // [서빙]: 완성된 요리(답변)를 손님에게 내어줍니다.
    return createJSONOutput({ 
      status: 'success', 
      answer: aiResponse 
    });

  } catch (error) {
    // [사고 처리]: 요리 중 문제가 생기면 사과문을 전달합니다.
    return createJSONOutput({ 
      status: 'error', 
      message: error.toString() 
    });
  }
}

/**
 * 2. [재료 손질 담당]: 구글 시트에서 데이터를 가져와 텍스트로 다듬는 함수
 * @return {String} - AI가 이해하기 쉽게 정리된 참고 자료
 */
function getSheetContext() {
  // [창고 진입]: 현재 스프레드시트의 'Data' 시트를 엽니다.
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Data');
  
  if (!sheet) return "참고할 데이터 시트가 없습니다.";

  // [재료 꺼내기]: 데이터가 있는 범위를 모두 가져옵니다. (A열: 질문, B열: 답변)
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return ""; // 데이터가 없으면 빈 문자열 반환

  const data = sheet.getRange(2, 1, lastRow - 1, 2).getValues();

  // [재료 다듬기]: "질문: ... / 답변: ..." 형태로 텍스트를 뭉칩니다.
  let contextString = "다음은 참고할 수 있는 데이터베이스입니다:\n";
  data.forEach(row => {
    if (row[0] && row[1]) {
      contextString += `- 질문: ${row[0]} / 답변: ${row[1]}\n`;
    }
  });

  return contextString;
}

/**
 * 3. [수석 셰프 호출]: 제미나이 API에 요청을 보내고 응답을 받는 함수
 * @param {String} userQuery - 사용자의 질문
 * @param {String} context - 시트에서 가져온 배경 지식
 * @param {String} apiKey - API 인증 키
 * @return {String} - 제미나이의 답변
 */
function callGeminiAPI(userQuery, context, apiKey) {
  // [레시피 작성]: 셰프에게 전달할 지시사항(프롬프트)을 만듭니다.
  const prompt = `
    당신은 친절한 챗봇입니다. 
    아래의 [Context]를 바탕으로 사용자의 [Question]에 답변해 주세요.
    Context에 없는 내용은 아는 대로 답변하되, Context를 우선순위로 두세요.

    [Context]
    ${context}

    [Question]
    ${userQuery}
  `;

  // [전송 준비]: API 요청 주소와 데이터 포장
  const url = `https://generativelanguage.googleapis.com/${API_VERSION}/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;
  
  const payload = {
    "contents": [{
      "parts": [{
        "text": prompt
      }]
    }]
  };

  const options = {
    "method": "post",
    "contentType": "application/json",
    "payload": JSON.stringify(payload),
    "muteHttpExceptions": true // 에러 발생 시에도 응답 내용을 확인하기 위함
  };

  // [요리 요청]: 외부 주방(Google Server)으로 요청을 보냅니다.
  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  const jsonResponse = JSON.parse(response.getContentText());

  // [검식]: 요리가 제대로 나왔는지 확인합니다.
  if (responseCode !== 200) {
    throw new Error(`Gemini API 오류: ${jsonResponse.error ? jsonResponse.error.message : '알 수 없는 오류'}`);
  }

  // [플레이팅]: 복잡한 JSON 응답에서 실제 텍스트 답변만 추출합니다.
  if (jsonResponse.candidates && jsonResponse.candidates.length > 0) {
    return jsonResponse.candidates[0].content.parts[0].text;
  } else {
    return "죄송합니다. 적절한 답변을 생성하지 못했습니다.";
  }
}

/**
 * 4. [포장 담당]: 결과를 JSON 형식으로 포장하여 반환하는 헬퍼 함수
 */
function createJSONOutput(data) {
  return ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}
```

### 🚀 배포 방법 (서빙 시작하기)

1.  위 코드를 스크립트 편집기에 붙여넣고 저장합니다.
2.  우측 상단 **[배포]** > **[새 배포]**를 클릭합니다.
3.  유형 선택 톱니바퀴에서 **[웹 앱]**을 선택합니다.
4.  설정:
    *   설명: `Gemini Chatbot v1`
    *   다음 사용자 계정으로 실행: **나(Me)** (중요: 시트 접근 권한 때문)
    *   액세스 권한이 있는 사용자: **모든 사용자** (외부에서 챗봇을 호출하려면 필수)
5.  **[배포]** 버튼을 누르고 생성된 **웹 앱 URL**을 복사하여 챗봇 프론트엔드나 테스트 도구(Postman 등)에서 사용합니다.

### 🧪 테스트 방법 (Postman 등)
*   **URL**: (복사한 웹 앱 URL)
*   **Method**: POST
*   **Body (JSON)**:
    ```json
    {
      "userQuery": "여기에 질문을 입력하세요"
    }
    ```