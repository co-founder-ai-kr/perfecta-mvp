# 민순의 요청

```text
* 역할: 너는 자바스크립트 코드 구조 개선 전문가야.
* 상황: 현재 '선물' 주제에 묶인 코드를 다른 아이템(책, 음식 등)에도 쓸 수 있게 범용화하고 싶어.
* 과업: 선물 추천 기능만 떼어내서, 다음 프로젝트에서도 바로 쓸 수 있는 독립적인 함수 템플릿으로 만들어 줘.
* 제약: 
  - '선물'이라고 된 부분들을 '상품'이나 '아이템'처럼 일반적인 단어로 바꿔 줘.
  - 각 줄에는 비즈니스 의도를 설명하는 주석을 달아 줘.
* 출력: 범용화된 자바스크립트 코드 블록.
* 입력: [기존 코드 붙여넣기]
```

# 제미나이의 응답

제공해주신 기존 코드가 없으므로, 통상적인 **'조건에 맞는 상품 필터링 및 추천 로직'**을 가정하여 가장 범용적으로 사용할 수 있는 **함수형 템플릿**을 작성해 드립니다.

이 템플릿은 **'입력(후보군) -> 필터링(조건) -> 정렬(우선순위) -> 추출(개수)'**의 흐름을 따르며, 선물뿐만 아니라 책, 음식, 숙소 등 어떤 도메인에도 적용 가능합니다.

```javascript
/**
 * 범용 아이템 추천 함수 템플릿
 * 
 * @param {Array} candidateItems - 추천 대상이 될 전체 아이템(상품) 목록
 * @param {Object} userPreferences - 사용자의 선호 조건 (예: 예산, 카테고리, 태그 등)
 * @param {Object} config - 추천 로직 설정 (예: 최대 추천 개수, 정렬 기준 함수 등)
 * @returns {Array} - 추천 로직을 통과한 최종 아이템 목록
 */
const recommendItems = (candidateItems, userPreferences, config = {}) => {
  // [초기화] 설정값이 없을 경우를 대비해 기본값(최대 3개 추천)을 할당합니다.
  const limit = config.limit || 3;

  // [유효성 검사] 후보 아이템 목록이 비어있다면 불필요한 연산을 막기 위해 빈 배열을 반환합니다.
  if (!candidateItems || candidateItems.length === 0) {
    return [];
  }

  // [1단계: 필터링] 비즈니스 규칙에 따라 부적합한 아이템을 제외합니다.
  const filteredItems = candidateItems.filter(item => {
    // [조건 1] 아이템이 현재 판매/사용 가능한 상태인지 확인합니다.
    const isAvailable = item.isAvailable === true;
    
    // [조건 2] 사용자의 예산 범위 내에 있는 아이템인지 확인합니다. (예산 제한이 있는 경우)
    const isWithinBudget = userPreferences.maxPrice 
      ? item.price <= userPreferences.maxPrice 
      : true;

    // [조건 3] 사용자가 선호하는 카테고리나 태그와 일치하는지 확인합니다. (커스텀 로직 적용 가능)
    const isMatchingCategory = userPreferences.category 
      ? item.category === userPreferences.category 
      : true;

    // [결과] 모든 필수 조건을 만족하는 아이템만 남깁니다.
    return isAvailable && isWithinBudget && isMatchingCategory;
  });

  // [2단계: 정렬] 필터링된 아이템 중 우선순위가 높은 순서대로 나열합니다.
  const sortedItems = filteredItems.sort((a, b) => {
    // [우선순위 로직] config에 별도 정렬 함수가 있다면 그것을 따르고, 없다면 평점(rating) 내림차순으로 정렬합니다.
    if (config.sortFn) {
      return config.sortFn(a, b);
    }
    // [기본 정렬] 평점이 높은 아이템이 먼저 오도록 배치합니다.
    return (b.rating || 0) - (a.rating || 0);
  });

  // [3단계: 추출] 최종적으로 상위 N개의 아이템만 잘라내어 반환합니다.
  return sortedItems.slice(0, limit);
};

// -------------------------------------------------------
// [사용 예시 1] 책 추천 (기존 '선물' 로직을 '책'으로 변경)
// -------------------------------------------------------
const books = [
  { id: 1, title: "자바스크립트 완벽 가이드", price: 35000, category: "IT", rating: 4.8, isAvailable: true },
  { id: 2, title: "요리 대백과", price: 20000, category: "Cooking", rating: 4.5, isAvailable: true },
  { id: 3, title: "리액트 프로그래밍", price: 28000, category: "IT", rating: 4.9, isAvailable: true },
];

const myBookPrefs = { maxPrice: 40000, category: "IT" };
const recommendedBooks = recommendItems(books, myBookPrefs, { limit: 2 });

console.log("추천된 책:", recommendedBooks);


// -------------------------------------------------------
// [사용 예시 2] 음식 메뉴 추천 (동일한 함수 재사용)
// -------------------------------------------------------
const foods = [
  { id: 101, name: "파스타", price: 15000, category: "Western", rating: 4.2, isAvailable: true },
  { id: 102, name: "스테이크", price: 50000, category: "Western", rating: 4.9, isAvailable: true },
  { id: 103, name: "피자", price: 20000, category: "Western", rating: 4.6, isAvailable: true },
];

// 정렬 기준을 '가격 낮은 순'으로 변경하고 싶을 때
const cheapFoodSort = (a, b) => a.price - b.price;

const myFoodPrefs = { maxPrice: 30000, category: "Western" };
const recommendedFoods = recommendItems(foods, myFoodPrefs, { limit: 1, sortFn: cheapFoodSort });

console.log("추천된 음식:", recommendedFoods);
```

### 💡 코드 개선 포인트 설명
1.  **네이밍 일반화**: `gifts` → `candidateItems`, `gift` → `item`으로 변경하여 어떤 상품이든 받을 수 있게 했습니다.
2.  **설정(Config) 분리**: 정렬 방식(`sortFn`)이나 개수 제한(`limit`)을 함수 내부가 아닌 외부에서 주입받도록 하여 유연성을 높였습니다.
3.  **주석 강화**: 각 라인이 수행하는 '비즈니스적 의미(유효성 검사, 예산 체크, 우선순위 결정 등)'를 명시했습니다.
4.  **확장성**: `userPreferences` 객체를 통해 예산 외에도 카테고리 등 다양한 필터 조건을 추가하기 쉬운 구조입니다.