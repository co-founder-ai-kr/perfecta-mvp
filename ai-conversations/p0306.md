# 민순의 요청

```text
* 역할: 너는 클라이언트 웹 환경을 점검하는 깐깐한 보안 전문가야.
* 상황: 작성된 코드에 보안 취약점이나 민감 정보 노출이 있는지 걱정하고 있어.
* 과업: 
  1. 코드 안에 비밀 번호나 API 키 같은 게 노출되어 있는지 확인해 줘. 
  2. 만약 있다면 안전한 처리 방법을 알려주고, 코드를 어디에 어떻게 고쳐야 하는지 위치를 콕 집어 알려 줘.
* 제약: 서버 구축 없이 클라이언트 측에서 할 수 있는 현실적인 대안으로 알려 줘.
* 출력: 점검 결과 및 수정 코드 (마크다운)
* 입력: [점검받을 코드 전체]
 (예시: <script>const API_KEY = "YOUR_SECRET_KEY";</script>)
```

# 제미나이의 응답

제시해주신 예시 코드(`<script>const API_KEY = "YOUR_SECRET_KEY";</script>`)를 바탕으로 보안 점검을 진행하겠습니다.

흠, 코드를 보니 보안 의식이 상당히 부족하군요. **API 키를 클라이언트 코드에 그대로 박아넣는 것(Hardcoding)**은 대문을 활짝 열어두고 도둑에게 "여기 귀중품이 있습니다"라고 광고하는 것과 다를 바 없습니다.

서버를 구축할 수 없는 환경이라는 제약 사항을 고려하여, **클라이언트 측에서 할 수 있는 최선의 현실적인 대안**을 제시해 드립니다.

---

### 🔍 점검 결과

*   **취약점 발견:** 소스 코드 내 민감 정보(API Key) 하드코딩
*   **위치:** `<script>` 태그 내부 `const API_KEY = "YOUR_SECRET_KEY";`
*   **위험도:** **[치명적]** (Critical)
*   **위험 분석:**
    1.  브라우저의 '소스 보기'나 '개발자 도구(F12)'를 통해 누구나 키를 탈취할 수 있습니다.
    2.  탈취된 키로 해커가 API를 무단 사용하여 **과금 폭탄**을 맞거나, 서비스의 **할당량(Quota)을 고갈**시킬 수 있습니다.

---

### 🛡️ 현실적인 대안 (서버 구축 X)

서버(백엔드)가 없다면 API 키는 필연적으로 브라우저를 거쳐야 하므로 **완벽한 은닉은 불가능**합니다. 하지만 다음 두 가지 조치를 통해 **"훔쳐 가도 못 쓰게"** 만들 수는 있습니다.

#### 1. API 공급사 콘솔에서 '사용 제한(Restriction)' 설정 (가장 중요)
코드를 고치는 것보다 이게 핵심입니다. API 키를 발급받은 사이트(Google Cloud, Firebase, OpenAI 등) 설정 페이지로 가세요.
*   **HTTP Referrer 제한:** 내 도메인(예: `mysite.com`)에서 오는 요청만 허용하도록 설정합니다. (로컬 테스트 시 `localhost` 추가)
*   **IP 제한:** 특정 IP에서만 요청을 허용합니다. (클라이언트 환경에서는 유동 IP 때문에 비추천)

#### 2. 환경 변수(.env) 사용 및 코드 분리
소스 코드에 키를 직접 적지 말고, 빌드 도구(Vite, Webpack 등)나 호스팅 서비스의 환경 변수 기능을 사용해야 합니다. 이렇게 하면 **GitHub 같은 저장소에 키가 업로드되는 것을 막을 수 있습니다.**

---

### 💻 수정 코드 및 적용 방법

단순 HTML/JS 환경인지, 모던 번들러(Vite/React 등) 환경인지에 따라 방법이 다릅니다. 가장 일반적인 두 가지 케이스로 나누어 알려드립니다.

#### Case A: 모던 프론트엔드 환경 (Vite, React, Vue 등 사용 시)

프로젝트 루트에 `.env` 파일을 만들고 키를 저장한 뒤, 코드에서 불러옵니다.

**1. `.env` 파일 생성 (프로젝트 최상위 경로)**
```env
# .gitignore에 이 파일이 반드시 포함되어야 합니다!
VITE_API_KEY=YOUR_ACTUAL_SECRET_KEY
```

**2. 코드 수정 (JS 파일)**
```javascript
// 기존: const API_KEY = "YOUR_SECRET_KEY";

// 수정: 환경 변수에서 불러오기
const API_KEY = import.meta.env.VITE_API_KEY; 

if (!API_KEY) {
  console.error("API 키가 설정되지 않았습니다. .env 파일을 확인하세요.");
}

// 이후 API 호출 로직...
```

#### Case B: 단순 HTML/JS 파일만 있는 경우 (정적 호스팅)

번들러가 없다면 별도의 `config.js` 파일을 만들고 `.gitignore`에 등록하여 관리하거나, 호스팅 서비스(Netlify, Vercel, GitHub Pages)의 **Environment Variables** 설정 메뉴에 키를 등록하고 빌드 시 주입받아야 합니다.

만약 로컬에서 단순히 HTML만 띄우는 경우라면, 최소한 **사용자에게 키를 입력받는 방식**으로 변경하여 내 키가 노출되는 것을 막아야 합니다.

**수정 코드 (사용자 입력 방식 제안)**

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>보안 점검 수정 예시</title>
</head>
<body>
    <!-- UI 구성 -->
    <div id="auth-section">
        <label for="user-api-key">API Key 입력:</label>
        <input type="password" id="user-api-key" placeholder="여기에 키를 입력하세요">
        <button onclick="saveKey()">저장 및 실행</button>
    </div>

    <script>
        // 1. 소스 코드 내 하드코딩 제거
        // const API_KEY = "YOUR_SECRET_KEY";  <-- 삭제!

        let apiKey = sessionStorage.getItem('my_api_key');

        function saveKey() {
            const inputKey = document.getElementById('user-api-key').value;
            if (!inputKey) return alert("키를 입력해주세요.");
            
            // 2. 브라우저 닫을 때까지만 유지되도록 sessionStorage 사용 (localStorage보다 안전)
            sessionStorage.setItem('my_api_key', inputKey);
            apiKey = inputKey;
            alert("키가 임시 저장되었습니다. API를 호출합니다.");
            runApp();
        }

        function runApp() {
            if (!apiKey) {
                console.warn("API 키가 없습니다.");
                return;
            }
            console.log("API 호출 시작... (키는 코드에 남지 않음)");
            // fetch('https://api.example.com/data', { headers: { Authorization: apiKey } })...
        }

        // 이미 입력된 키가 있으면 바로 실행
        if (apiKey) runApp();
    </script>
</body>
</html>
```

### ⚠️ 전문가의 마지막 경고
> "클라이언트 사이드에 저장된 키는 어떤 방식으로든(환경 변수 포함) 브라우저 네트워크 탭을 통해 볼 수 있습니다. 따라서 **API 공급사 콘솔에서 '도메인 제한(Referrer Restriction)'을 거는 것만이 유일한 살길**임을 명심하세요."